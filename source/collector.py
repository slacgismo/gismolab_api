"""GISMoLab Data Collector

The `Collector` class implements a general data collection management object.
The collector uses a thread to poll incoming data and move it to the archive.

Example
-------

The following example illustrates creating a polling function and archive
function and starting the data collector, verifying data was collected,
and stopping the data collector.

    data = []
    co = Collector(
        poller = lambda:random.uniform(0,1), # source of data
        archive = lambda x.data.append(x), # sink of data
        freq = 1, # update rate (in seconds)
        start = True) # start
    assert(co.is_polling())
    co.wait()
    assertGreater(self.get_value(),0)
    co.stop_polling()
    assert(not co.is_polling())
    del co
"""
import sys, os
import threading
import requests
import time
import random

class CollectorException(Exception):
    """Exception generated by collector objects"""
    pass

DEBUG = False # enables debugging output

class Collector:

    default_freq = 1
    collector_list = {}

    def __init__(self,
            name = None,
            poller = None,
            freq = None,
            archive = None,
            parser = None,
            start = False,
            ):
        """
        Construct a collector object

        ARGUMENTS

            name (str) - collector name (random hex value if None)

            poller (callable) - function to call to poll for data

            freq (float) - polling frequency (in seconds, default None)

            archive (callable) - data delivery function (default None)

            parser (callable) - data conversion function (default lambda x:x)

            start (bool) - automatic polling start flag (default False)

        DESCRIPTION

            The collector name is automatically generated as a 64 bit hex
            string if none is given.

        EXCEPTIONS

            CollectorException
        """
        self.name = f"{name}" if name else hex(random.randint(0,int(1e64)))[2:]
        if self.name in self.collector_list:
            raise CollectorException(f"collector '{self.name}' already exists")
        else:
            self.collector_list[name] = dict(collector = self)
        self.main_thread = threading.current_thread()
        self.thread = None
        self.new_data_event = threading.Event()
        self.polling_active = threading.Event()
        self.value = None
        self.set_archive(archive)
        self.set_parser(parser)
        self.set_poller(poller)
        self.set_freq(freq if freq != None else self.default_freq,start)

    def __del__(self):
        try:
            del self.collector_list[self.name]
        except:
            pass

    def __exit__(self):
        try:
            del self.collector_list[self.name]
        except:
            pass

    def debug(self,msg):
        """Output a debug message"""
        if DEBUG:
            print(f"DEBUG [<collector:{self.get_name(6)}>]: {msg}",file=sys.stderr)

    def error(self,msg):
        """output an error message"""
        print(f"ERROR [<collector:{self.get_name(6)}>]: {msg}",file=sys.stderr)

    def warning(self,msg):
        """output a warning message"""
        print(f"WARNING [<collector:{self.get_name(6)}>]: {msg}",file=sys.stderr)

    @classmethod
    def stop_all(cls,wait=False):
        """Stop all collectors

        ARGUMENTS

            wait (bool or float) - wait for collectors to stop, timeout if float
        """
        for name,data in cls.collector_list.items():
            data['collector'].stop_polling(wait=wait)

    def get_name(self,trimhex=None):
        """Get the collector name

        ARGUMENTS

            trimhex (int or None) - length limit for hex name (default None)

        RETURNS
            
            str - collector name
        """
        try:
            return self.name[:trimhex] if int("0x"+self.name,base=16)>0 else self.name
        except:
            return self.name

    def is_polling(self):
        """Check collector polling status

        RETURNS

            bool - True if polling is active
        """
        self.debug(f"is_polling: thread = {self.thread}")
        return self.thread and self.thread.is_alive() and self.polling_active.is_set()

    def start_polling(self,freq=None):
        """Start collector polling

        ARGUMENT

            freq (float or None) - polling frequency in seconds
        """
        self.debug(f"start_polling(freq={freq}): thread = {self.thread}")
        if self.thread and self.thread.is_active():
            raise CollectorException("polling is already started")
        if not freq is None and freq > 0:
            self.freq = freq
        else:
            raise CollectorException("frequency must be strictly positive")
        def updater():
            self.debug(f"updater starting at freq = {self.freq}")
            self.polling_active.set()
            while self.polling_active.is_set() and self.main_thread.is_alive():
                started_at = time.time()
                try:
                    self.value = self.poller() if self.poller else None
                    self.debug(f"update value = {self.value}")
                    self.new_data_event.set()
                    if self.archive:
                        self.archive(self.value)
                except Exception as err:
                    self.error(f"polling exception -- {err}")
                try:
                    wait_time = self.freq - (time.time() - started_at)
                    if wait_time > 0:
                        time.sleep(wait_time)
                    else:
                        self.warning(f"update rate of {self.freq:.1f} seconds is too high for {self.freq-wait_time:.1f} seconds used by poll and archive process")
                except:
                    pass
            self.debug("updater stopped")
            self.polling_active.clear()
            if not self.main_thread.is_alive():
                try:
                    del self.collector_list[self.name]
                except:
                    pass
        self.thread = threading.Thread(target=updater)
        self.thread.start()
        self.debug(f"polling started: thread = {self.thread}")

    def stop_polling(self,wait=True):
        """Stop collector polling

        ARGUMENTS

            wait (float or bool) - wait timeout if any, True is maximum timeout
        """
        if self.thread:
            self.debug(f"stop_polling: thread = {self.thread}")
            if self.thread.is_alive():
                self.polling_active.clear()
                if wait:
                    self.debug(f"wait for thread to exit")
                    self.thread.join(timeout = wait if type(wait) is int else None)
                    self.debug(f"polling stopped thread = {self.thread}, is_polling = {self.is_polling()}")
            del self.thread
            self.thread = None

    def set_parser(self,parser):
        """Set data parser

        ARGUMENTS

            parser (callable) - data converter from poller to archiver (default is lambda x:x)
        """
        self.parser = parser if parser else (lambda x:x.value)

    def set_poller(self,poller):
        """Set data poller

        ARGUMENTS

            poller (callable) - data polling function to call (None disables polling)
        """
        if poller is None or callable(poller):
            self.poller = poller
        else:
            raise CollectorException("poller must be callable or None")

    def set_archive(self,archive):
        """Set data archiver


        ARGUMENTS

            archive (callable) - data archive function to call (None disable archiving)
        """
        if archive and not callable(archive):
            raise CollectorException("archive is not callable")
        else:
            self.archive = archive

    def set_freq(self,freq,restart=True):
        """Set polling frequency


        ARGUMENTS

            freq (float) - polling frequency to use

            restart (bool) - flag to restart polling immediate instead of waiting to next update
        """
        if freq > 0:
            if restart:
                if self.is_polling():
                    self.stop_polling()
                self.start_polling(freq)
        elif freq is None:
            self.stop_polling()
        else:
            raise CollectorException("frequency must be positive or None")

    def wait(self,timeout=None):
        """Wait for new data

        ARGUMENTS

            timeout (float or None) - wait timeout before CollectorException

        RETURNS

            bool - True indicates that new data is available, otherwise False
        """
        self.debug("waiting for new data")
        self.new_data_event.clear()
        self.new_data_event.wait(timeout=timeout)
        if timeout and not self.new_data_event.is_set():
            raise CollectorException(f"wait timeout after {timeout}")
        return self.new_data_event.is_set()

    def get_value(self):
        """Get last value received

        RETURNS
            
            value - last value received (see parser)
        """
        self.new_data_event.clear()
        return self.value

if __name__ == "__main__":

    import unittest
    import random
    import inspect

    # DEBUG = True

    class TestCollector(unittest.TestCase):

        def test_stack(self):
            Collector(
                name = inspect.stack()[0][3],
                poller = lambda:random.uniform(0,1),
                freq = 1,
                start = True)

        def test_start(self):
            co = Collector(
                name = inspect.stack()[0][3],
                poller = lambda:random.uniform(0,1),
                )
            co.start_polling(freq=0.1)
            # co.wait(0.2)
            self.assertGreater(co.get_value(),0)

        def test_delete(self):
            co = Collector(
                name = inspect.stack()[0][3],
                poller = lambda:-random.uniform(0,1),
                freq = 0.1,
                start = True)
            co.wait(0.2)
            del co

        def test_polling(self):
            co = Collector(
                name = inspect.stack()[0][3],
                poller = lambda:random.uniform(0,1),
                freq = 0.1,
                start = True)
            self.assertTrue(co.is_polling())
            co.wait(0.2)
            self.assertGreater(co.get_value(),0)
            co.stop_polling()
            self.assertFalse(co.is_polling())

        def test_archive(self):
            data = []
            co = Collector(
                name = inspect.stack()[0][3],
                poller = lambda:random.uniform(0,1),
                archive = lambda x:data.append(x),
                freq = 0.1,
                start = True)
            co.wait(0.2)
            self.assertGreater(len(data),0)
            del co

        def test_stopall_nowait(self):
            co1 = Collector(name = inspect.stack()[0][3]+"-1",poller=lambda:0,freq=0.1,start=True)
            co2 = Collector(name = inspect.stack()[0][3]+"-2",poller=lambda:0,freq=0.1,start=True)
            Collector.stop_all()

        def test_stopall_wait(self):
            co1 = Collector(name = inspect.stack()[0][3]+"-1",poller=lambda:0,freq=0.1,start=True)
            co2 = Collector(name = inspect.stack()[0][3]+"-2",poller=lambda:0,freq=0.1,start=True)
            Collector.stop_all(wait=0.1)

    unittest.main()
